*********

Welcome to Project 64!

  The goal of Project 64 is to preserve Commodore 64 related documents
in electronic text format that might otherwise cease to exist with the
rapid advancement of computer technology and declining interest in 8-
bit computers on the part of the general population.

  Extensive efforts were made to preserve the contents of the original
document.  However, certain portions, such as diagrams, program
listings, and indexes may have been either altered or sacrificed due
to the limitations of plain vanilla text.  Diagrams may have been
eliminated where ASCII-art was not feasible.  Program listings may be
missing display codes where substitutions were not possible.  Tables
of contents and indexes may have been changed from page number
references to section number references. Please accept our apologies
for these limitations, alterations, and possible omissions.

  The author(s) of the original document and members of Project 64 make
no representations about the accuracy or suitability of this material
for any purpose.  This etext is provided "as-is".  Please refer to the
warantee of the original document, if any, that may included in this
etext.  No other warantees, express or implied, are made to you as to
the etext or any medium it may be on.  Neither the author(s) nor the
members of Project 64 will assume liability for damages either from
the direct or indirect use of this etext or from the distribution of
or modification to this etext.  Therefore if you read this document or
use the information herein you do so at your own risk.

*********

  The Project 64 etext of Inside Commodore DOS by Richard Immers, Ph.D.
and Gerald G. Neufeld, Ph.D. second edition. Converted to etext by
Silver Dream !

INCDOS01.TXT (WIP), April 2014

*********
﻿
                              INSIDE
                             COMMODORE
                                DOS
﻿
﻿



                                INSIDE
                              COMMODORE
                                 DOS

                                  by

                        Richard Immers, Ph.D.
                        Adrian Public Schools
                          Adrian, Michigan

                                and

                      Gerald G. Neufeld, Ph.D.
                        Brandon University
                         Brandon, Manitoba
                              Canada


                    Technical Illustrations by
                        Diane M. Corralejo

                           DATAMOST, Inc.
            19821 Nordhoff Street, Northridge, CA 91324
                          (818) 709-1202
﻿



                    First Printing, July 1984
                  Second Printing, February 1985







                 RESTON PUBLISHING COMPANY, INC.
                    A Prentice-Hall Company
                       Reston, Virginia

                       ISBN 0-8359-3091-2

                Copyright © 1984 by DATAMOST, Inc.
                       All Rights Reserved

This manual is published and copyrighted by DATAMOST, Inc. All rights are
reserved by DATAMOST, Inc. Copying, duplicating, selling or otherwise
distributing this product is hereby expressly forbidden except by prior written
consent of DATAMOST, Inc.

The words COMMODORE, CBM, COMMODORE 64, VIC-20, VIC-1541 and the Commodore logo
are registered trademarks of Commodore Business Machines, Inc.

Commodore Business Machines was not in any way involved in the writing or other
preparation of this manual, nor were the facts presented here reviewed for
accuracy by them.

The information presented in this manual is the result of intensive study of
the disassembly of the 1541 DOS. Every effort has been made to provide
error-free information. However, neither the authors nor DATAMOST, Inc. can
accept responsibility for any loss or damage, tangible or intangible, resulting
from use or improper or unintended use of this information.

                                                       Printed in U.S.A.
﻿


                        ACKNOWLEDGEMENTS

A manual like this one would not be possible without a great deal of technical
assistance. Mike Todd's Disk File column in the ICPUG Newsletter proved to be
an invaluable source of insight into the inner workings of Commodore's DOS.
Raeto West's book, Programming the PET/CBM, was a constant companion. Jim
Butterfield's numerous articles also provided valuable bits and pieces of
information. Brad Templeton's POWER™ system and PAL™ assembler made the
development of the programs in this manual a real joy. These packages are
commercially available from Professional Software Inc. In addition, both the
PAL disassembler and MICROMON were used as tools for disassembling the 1541 DOS.

We would also like to acknowledge the patience and forebearance of our families
and friends. Without their support, producing this manual would have been
considerably more difficult. Mike Louder of DATAMOST, Inc. also provided
tremendous support for its production.

Finally, we would like to extend a special note of thanks to Dr. Tom MacNeil
and Nancy Neufeld for their diligent work in proofreading this manual.

This manual was written on a Commodore computer system using the WordPro 4 Plus
word processing system. The WordPro Plus™ Series is commercially available from
Professional Software Inc. This sophisticated word processing system made
editing and last minute revisions much easier.
﻿
﻿



                        TABLE OF CONTENTS

Chapter 1 - INTRODUCTION
            A Brief Word About the Programs
            How to Type in the Programs

Chapter 2 - USING THE 1541'S DOS
            The Purpose of DOS
            Communicating with the 1541
            The Command Channel
            Using the Command Channel
            Diskette Housekeeping

Chapter 3 - DISKETTE FORMATTING
            Layout of Tracks and Sectors
            Layout of a Sector
            The Header Block
            The Data Block

Chapter 4 - DISKETTE ORGANIZATION
            Information Management
            The Directory You See
            The Block Availability Map
            The Directory Entries
            Program File Storage
            Sequential File Storage
            Relative File Storage
            User File Storage
            Deleted File Storage
            Locked Files

Chapter 5 - DIRECT-ACCESS PROGRAMMING
            Introduction to Direct-Access Programming
            Beginning Direct-Access Programming
            Block-Read Command
            Buffer-Pointer Command
            Block-Write Command
            Memory-Read Command
            Memory-Write Command
            Block-Allocate Command
            Block-Free Command
            Memory-Execute Command
            Block Execute Command
            Direct-Access Entomology

Chapter 6 - INTERMEDIATE DIRECT-ACCESS PROGRAMMING

Chapter 7 - DOS PROTECTION
            Commodore's Data Encoding Scheme
            Checksums
            Description of DOS Error Messages
            Analyzing a Protected Diskette
            Duplicating a Protection Scheme
            How to Create 21 Errors on a Full Track
            How to Create a 21 Error on a Single Sector
            How to Create a 23 Error on a Single Sector
            How to Duplicate a 23 Error on a Single Sector
            How to Create 23 Errors on a Full Track
            How to Create 20 Errors on a Full Track
            How to Create 27 Errors on a Full Track
            How to Create a 22 Error on a Single Sector
            How to Duplicate a 22 Error on a Single Sector
            How to Format a Diskette with Multiple IDs
            How to Backup a DOS Protected Diskette
            How to Copy a File

Chapter 8 - GETTING OUT OF TROUBLE
            Unscratching a File
            Recovering a Soft Sector
            Recovering a Hard Sector
            Recovering a Relative File
            Recovering an Entire Diskette
            Recovering a Physically Damaged Diskette
            Recovering an Unclosed File
            Recovering from a Short New
            Recovering from a Full New

Chapter 9 - OVERVIEW OF THE 1541 DOS
            Introduction to 1541 DOS
            The Hard Working 6502
            Major IP Routines
            Using the IP Routines
            Major FDC Routines
            Using the FDC Routines
            The Recording Process
            Block Diagram of the 1541
            Writing Data to a Diskette
            Reading Data From a Diskette
            Summary Bugs in DOS 2.6
            Write Incompatibility with 4040
            Late News

Appendix A - 1541 RAM VARIABLE DEFINITIONS

Appendix B - ANALYSIS OF THE 1541's ROM

Appendix C - PROGRAM LISTINGS

Appendix D - MATHEMATICAL CONVERSION ROUTINES

Index
﻿
Ignorance is a precious thing.
Once lost, it can never be regained.
﻿
CHAPTER 1

INTRODUCTION

This manual is intended to supplement the documentation provided in the 1541
User's Manual. Although this manual is primarily designed to meet the needs of
the intermediate to advanced programmer, it will also be of interest to the
novice Commodore user who wants to know more about how his 1541 disk drive
works. This manual is not intended to replace the documentation provided by
Commodore Business Machines, Inc. and the reader is assumed to be relatively
familiar with the contents of the 1541 User's Manual. For the sake of
continuity and clarity, some of the information covered in the 1541 User's
Manual is also presented here. However, the majority of the information
presented in this manual is original and is the result of intensive disassembly
and annotation of the 1541's DOS by the authors. Some information is based on
articles and notes published in a variety of publications as well as
discussions with other knowledgeable disk experts.

This manual was not prepared with the assistance of Commodore Business
Machines, Inc. Although we cannot guarantee the accuracy of all the information
presented in this manual, the material has been thoroughly researched and
tested.

There were several reasons for writing Inside Commodore DOS:

1. To correct errors and omissions in the 1541 User's Manual.
2. To help you make more effective use of your disk drive.
3. To provide complete information on diskette formatting.
4. To provide complete information on the storage of files.
5. To allow you to read and write data in non-standard ways.
6. To help you make a backup copy of your "protected" diskettes.
7. To help you recover damaged diskettes.
8. To help you understand the operation of your disk drive.

Although this manual focuses primarily on the 1541 disk drive, much of the
information also applies to other Commodore disk drives.

1.1 A Brief Word About the Programs

This book contains listings for 46 ready-to-use programs written in BASIC.
These programs are copyrighted. They may NOT be used commercially, in whole
or in part, period. Since many of the programs are long, typing them all in
would be a time consuming, tedious task. Feel free to share your typing efforts
with a friend who has also purchased a copy of this book. In return, we simply
ask that you do not share a program with someone who does not own a
legitimate copy of this book.

The programs in this book are disk utilities. They do not use flashy graphics
or sound. Rather, they are extremely powerful tools. Remember, any tool can be
dangerous if it is used improperly. Be sure that you know what you are doing
before you use a given program. Always experiment with a program on a test
diskette before you actually use it on one that contains valuable programs or
data. Practice makes perfect.

Each program was individually tested on a variety of 1541 disk drives having a
wide range of serial numbers. Moreover, each program always worked perfectly.
Unfortunately, it is impossible to guarantee that a particular program will
work with your model. If a given program does not seem to work properly, check
your typing carefully. Any errors, especially in the DATA statements which
contain a machine language program, will produce problems.

As a courtesy to the more advanced programmer, we have also included the source
listings for each machine language routine A source listing immediately follows
a related BASIC program listing and has a file name ending in ".PAL". It is for
use with the PAL assembler. Note: If you are using a different assembler, you
may have to make some minor changes.

The programs in this book were designed to be not only useful and beneficial,
but instructive as well. Many of them illustrate the "state of the art" in
the use of Commodore's direct-access disk commands. Enjoy!

1.2 How to Type in the Programs

Program listings in books and magazines often suffer from two problems:
typographical errors that occur when the program is retyped into a word
processor and the readability of Commodore's control characters (e.g., the
reverse field heart that means Clear Screen). To overcome these problems, the
program listings for this book were created using a special "lister" program.
This lister program took a working BASIC program and converted it into a
WordPro™ file. At the same time, control characters were spelled out in words
and surrounded by curly brackets. For example, a reverse field heart was
converted to {CLR}. The table below summarizes the listing conventions, the
corresponding control characters, and the proper key/keys to press on your
C64 or VIC-20.

When You See            What It Represents      What You Type
----------------        --------------------    --------------
{CLR}                   Clear Screen            Hold down SHIFT and press
                                                CLR/HOME
{HOME}                  Home Cursor             Press CLR/HOME
{DOWN}                  Cursor Down             Press CRSR/DOWN
{UP}                    Cursor Up               Hold down SHIFT and press
                                                CRSR/UP
{RIGHT}                 Cursor Right            Press CRSR/RIGHT
{LEFT}                  Cursor Left             Hold down SHIFT and press
                                                CRSR/LEFT
{RVS}                   Reverse Field ON        Hold down CTRL and press 9
{ROFF}                  Reverse Field OFF       Hold down CTRL and press 0

NOTE 1: When a number appears inside the curly brackets, it means you repeat
the control character immediately to the left of the number that many times.
For example:

{DOWN 5} means to press CRSR/DOWN five (5) times.

NOTE 2: All programs have been listed in a column 40 characters wide. Except
where special characters have been spelled out between curly brackets, the
lines are listed exactly as they appear on a Commodore 64 display. Spaces must
be typed in as listed. Where necessary, count the character columns to
determine the appropriate number of spaces.

Happy hunting and pecking!
﻿
﻿
                                CHAPTER 2

                          USING THE 1541'S DOS

2.1 The Purpose of a DOS

A disk operating system (DOS) is a machine language program that controls a
disk drive. It does several different tasks:

1. Handling communications between a disk drive and a computer.
2. Carrying out housekeeping chores such as formatting a diskette.
3. Managing the storage of information on a diskette.
4. Reading and writing information onto a diskette's surface.

In many computer systems, a DOS is loaded into the main computer's memory from
diskette when the computer is first switched on. In this type of system many of
the tasks are carried out using the computer's microprocessor and RAM.
Commodore uses a different approach. All of Commodore's disk drives are
intelligent peripherals. They do not have to use the computer's resources; they
have their own. For example, the 1541 disk drive contains its own 6502
microprocessor, 2K of RAM, two 6522 I/O chips, and a DOS program permanently
stored in 15.8K of ROM.

The advantages of having an intelligent disk drive are:

1. The DOS does not use any of the computer's memory.
2. Some disk operations can be carried out independently from the CPU.
3. Disk operations do not slow down processing.
4. One disk drive can be shared among several computers.

The disadvantages of having an intelligent disk drive are:

1. It is very difficult to customize DOS routines.
2. You must replace the ROMs to convert to a new version of DOS.


2.2 Communicating with the 1541

Your Commodore 64 or VIC-20 can communicate with your 1541 disk drive in
several ways:

1. Through the LOAD, SAVE, and VERIFY commands.
2. Through I/O using the command channel.
3. Through I/O using data communication channels.

Let's examine each of these in greater detail.

1. LOAD, SAVE, and VERIFY commands:

These BASIC commands are used to store and retrieve programs on the Commodore
tape and disk drives. They are designed for ease of use, even by the novice.
The BASIC interpreter in the computer interprets these commands and sends the
disk drive the necessary information over the serial bus.

2. I/O using the command channel:

The command channel is used to send messages to the disk drive to carry out
disk operations like: formatting a blank diskette, erasing an unwanted file,
renaming a file, etc. These operations are often referred to as disk
housekeeping. The command channel is also used to input messages, such as the
current error status of the drive, generated by the DOS. For more details on
how to use the command channel, see Section 2.4.

3. I/O using data communication channels:

The 1541 DOS supports a variety of kinds of files: program files, sequential
files, relative files, user files, and direct-access files. The storage and
retrieval of information in files is carried out using a data communication
channel. Although this manual provides detailed information regarding how files
are stored and organized, no attempt is made to teach you how to develop
programs that make extensive use of file handling. We would encourage readers
who are interested in file handling techniques to refer to Jim Butterfield's
series of articles in COMPUTE!. The only I/O applications discussed in this
manual are those relating to direct-access programming (see Chapter 5).

Since the rest of this manual makes extensive use of the command channel, let's
examine it in some detail.

2.3 The Command Channel

The command channel (channel number 15) is an important communication link
between your computer and the 1541 disk drive. It has several important
functions. You can use it to:

1. Monitor the error status of the drive to ensure that everything is operating
properly.
2. Send commands that direct the DOS to perform various housekeeping chores
associated with disk handling.
3. Send commands that direct the DOS to read or write information to specific
areas on a diskette.

This chapter focuses on the first two of these uses. Chapter 5 provides more
detail on reading or writing to a diskette.

2.4 Using the Command Channel

Using the command channel is easy. Just follow these steps:

1. Establish communications using an OPEN statement.
2. Send commands to the DOS using a PRINT# statement.
3. Read DOS messages using a GET# or INPUT# statement.
4. Close the channel using a CLOSE statement when you are finished.

Let's go over each step to ensure that you know exactly what to do.

1. Establishing communications using an OPEN statement.

In order to establish a communication channel between your computer and your
1541 disk drive, you use an OPEN statement. An OPEN statement is a BASIC
command which looks like this:

SYNTAX:         OPEN file#, device#, channel#
EXAMPLE:        OPEN 15, 8, 15

where

file#           = the logical file number (1-127)
device#         = the device number (8 for a stock 1541)
channel#        = the channel number or secondary address (2-15)

NOTE:   Channel numbers 0 & 1 are reserved for use by the DOS.
        Channel numbers 2-14 are data communications channels.
        Channel number 15 is the command channel.

The OPEN statement can be used either in immediate mode (typed and executed
directly from the keyboard) or under program control (embedded in a program).

In the example above (OPEN 15, 8, 15) we opened logical file number 15 on the
C64 to device number 8 (the disk drive) through channel 15 (the command
channel).

2. Sending commands to the DOS using a PRINT* statement.

In order to send commands from your computer to the 1541, you use a PRINT#
statement. A PRINT# statement is a BASIC command which looks like this:

SYNTAX:         PRINT# file#, "command"
EXAMPLE:        PRINT#15, "N0:MY DISKETTE,MD"

where

file#   = the logical file number you used when you opened the command channel
command = the disk command to be sent to the DOS

NOTE: The statement is PRINT# not PRINT #. You must not put a space before the
# sign. Spaces following the # sign are always optional. DO NOT use ?# as an
abbreviation either. The correct abbreviation is pR (p then SHIFTED R).

In this example, the disk command is "N0:MY DISKETTE,MD". This command causes
the DOS to prepare the blank diskette in the drive for first-time use.

Although there are many different disk commands, they fall into two groups:

1. Commands related to disk housekeeping.
2. Commands to read or write data to a diskette or the disk drive's RAM.

The disk housekeeping commands are discussed in the next part of this chapter.
The commands relating to reading or writing data are discussed in Chapter 5 on
Direct-Access Programming.

3. Reading DOS messages using a GET# or an INPUT# statement.

You may use either an INPUT# or a GET# statement to read the command channel
and access any messages or data prepared for the computer by the DOS. Both
INPUT# and GET# statements are BASIC commands. They look like this:

SYNTAX:         INPUT# file#, variable list
                GET# file#, variable list

EXAMPLE:        INPUT# 15, EN, EM$, ET, ES
                GET# 15, A$

where

file#           = the logical file number you used when you opened the command
                  channel
variable list   = one or more variable names separated by commas

NOTE: As was noted for PRINT# above, the BASIC statements are INPUT# and GET#,
not INPUT # and GET #. You must not put a space before the # sign. Spaces
following the # sign are always optional. Neither the INPUT# statement nor the
GET# statement can be used in immediate mode (typed and executed directly from
the keyboard). They must be included within a program.

The INPUT# command and the GET# command operate in much the same way as the
more familiar INPUT and GET commands. INPUT# always reads as far as the next
carriage return character while GET# reads a single byte of information.
Generally, GET# is used in direct-access programming and INPUT# is used only
for monitoring the drive's error status as indicated immediately below.

You can check the error status of your disk drive using the command channel.
The DOS monitors every disk operation as it is carried out and prepares a
status report indicating whether or not the operation was completed
successfully. The report consists of an error code number, an English language
message, and the track and sector where the problem, if any, was encountered.
Here is a subroutine that checks the error status.

100 OPEN 15,8,15 : REM THE OPEN COMMAND CHANNEL
        .       .       .
500 INPUT#15,EN,EM$,ET,ES : REM INPUT THE ERROR STATUS
51O IF EN < 20 THEN RETURN : REM NO ERROR ENCOUNTERED
520 PRINT EN;EM$;ET;ES : REM PRINT THE ERROR STATUS ON SCREEN
530 CLOSE 15 : END : REM ABORT ON BAD STATUS

Line 100 opens the command channel. It is a good idea to open the command
channel at the beginning of your program and leave it open until the end. Line
500 inputs the status report. The error code number is stored in EN, the
message in EM$, the track in ET, and the sector in ES. Error codes less than 20
may be ignored (line 510). A complete list of the error codes and messages is
contained in the back of your 1541 User's Manual. A detailed explanation of the
nature and cause of many of these errors is provided in Chapter 7 on Disk
Protection.

4. CLOSE the command channel when you are done.

After you have finished using the command channel, it should be closed. Recall
that the OPEN command has three parameters: the logical file number, the device
number, and the channel number. The CLOSE command has only one, the logical
file number. It looks like this:

SYNTAX:         CLOSE file#
EXAMPLE:        CLOSE 15

where

file# = the logical file number you used when you opened the command channel

NOTE: Loading, running, or editing a program closes down all communication
channels automatically. The command channel is closed properly in each
instance. However, data channels are aborted rather than closed. When a data
channel is aborted, the file is NOT CLOSED properly on the disk drive. You do
not have to close the command channel after the issuance of every command. If
you forget to close it, the worst that can happen is a ?FILE OPEN ERROR when
you attempt to open it again. However, you should get into the habit of always
closing a file when you are finished using it. You won't get into trouble
leaving the command channel open, but you may lose an important data file if
you leave a data communication channel open.


2.5 Disk Housekeeping

As your collection of programs grows, you will have to do some housekeeping to
keep things in shape. Disk housekeeping chores include the following:

1. Preparing a blank diskette for first-time use.
2. Erasing the contents of a diskette currently in use.
3. Initializing a diskette.
4. Renaming a file.
5. Scratching or erasing a file.
6. Copying a file.

These operations are carried out by the DOS in response to commands sent to the
drive using the command channel as indicated above. Once a disk housekeeping
command is issued, the disk drive will carry out the task without further
intervention by the computer. This means that you could edit or even RUN a
program in RAM while the disk drive busily formats or validates a diskette.
This is not really spooling. It occurs because the 1541 is an intelligent
peripheral. The only thing that will cause your computer to wait for the disk
drive to complete its task is your attempting to perform another disk
operation. This includes closing the command channel.

Let's take a look at the disk commands used for housekeeping. NOTE: If you are
using the DOS SUPPORT program that came on your 1541TEST/DEMO, the syntax for
these disk commands is remarkably shorter. The > or @ keys are used to send a
command to the disk drive. They take the place of the PRINT* statement. In
addition, you do not have to open or close the command channel or embed the
disk command in quotation marks. The DOS SUPPORT program will do this
automatically for you. The DOS 5.1 syntax can be used only in immediate mode,
however. It cannot be used in a program or a ?SYNTAX ERROR will result.


The New Command

When a fresh diskette is taken from its storage envelope, the 1541 cannot
recognize it. The diskette must be formatted or newed prior to first-time use.
Formatting or newing a diskette is performed by the DOS. The DOS proceeds to
write concentric tracks made up of blocks/sectors to the diskette. In addition,
a directory is set up, wherein the drive records information about all the
files stored on the diskette. Chapter 3 provides a much more detailed account
of this operation. The syntax for formatting a diskette is really quite simple:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "N0:DISK NAME,ID"
                CLOSE 15

ALTERNATE:      PRINT#15, "N:DISK NAME,ID"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "N0:MY DISKETTE,MD"
                CLOSE 15

DOS 5.1:        >N0:DISK NAME,ID
                >N:DISK NAME,ID

The disk command, "N0:MY DISKETTE,MD", is sent to the drive by the PRINT#15
statement. The command has three parameters. The first parameter within quotes
is N0:. The N stands for NEW. The 0 is a holdover from the dual drive system
and indicates which drive. The 0 is optional on the 1541 and may be omitted.
The colon terminates the DOS command. The second parameter is the disk name. It
is limited to 16 characters in length. Generally these are alphanumeric
characters. In the example above, we named the diskette: MY DISKETTE. The disk
name is cosmetic and appears in the directory for reference purposes only. It
is not written anywhere else on the diskette. The disk name is followed by a
comma. The DOS looks or parses for this. After the comma are two alphanumeric
characters for the disk ID. In the above example we selected MD as our disk
identifier. The ID is written to every block or sector on the diskette. It is
impossible to alter. The DOS repeatedly looks at the ID of a sector to be sure
that you have not switched diskettes on it. Each diskette should be formatted
with a unique ID. This will prevent the DOS from inadvertently overwriting
programs on what appears to be an identical diskette.

A "full" new on a diskette takes roughly 2-3 minutes. There is a quicker way to
erase a diskette that has already been used. This is accomplished by leaving
off the disk ID. For example:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "N0:DISK NAME"
                CLOSE 15

ALTERNATE:      PRINT#15, "N:DISK NAME"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "N0:TEST DISKETTE"
                CLOSE 15

DOS 5.1:        >NO:DISK NAME
                >N:DISK NAME

Notice that no comma or ID follows the disk name. This command will work only
on a diskette that has previously been formatted. It is referred to as a
"short" new. A "short" new simply erases the first sector in the directory and
writes an empty BAM (block availability map) to tell the DOS that we have a
fresh diskette in use. NOTE: A diskette that is plagued by read or write errors
does not have to be pitched. Copy the files to another diskette first. Then do
a "full" new on the offending diskette. This will erase and reformat the entire
diskette. A "short" new rewrites only sectors 0 and 1 of track 18 and will not
eliminate any read or write errors. See Chapter 8 about how to recover from
both a "short" new and a "full" new.


The Initialize Command

Initialization has nothing to do with formatting. APPLE™ owners format a
diskette by "initializing" it. This is NOT TRUE with Commodore. Initializing a
diskette forces the DOS to read the disk ID and the contents of the BAM and
store them in the drive's internal memory. The BAM establishes where the next
available sector is for writing. Without it files would be overwritten. To
initialize a diskette perform the following:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "I0"
                CLOSE 15

ALTERNATE:      PRINT#15, "I"

DOS 5.1:        >I0
                >I

The I is short for INITIALIZE. The drive number can be ignored if you are using
only one 1541. The drive motor purrs for a few seconds and then settles down.
It's that simple. It is a good habit to initialize a diskette each time you
insert it into your 1541 drive. This point cannot be overemphasized. Do it
yourself. Do not rely upon the "autoinit" feature of the drive. Initialization
prevents the DOS from overwriting files in the event that two diskettes with
identical IDs are swapped. The drive cannot tell the difference between two
diskettes with identical IDs since it is the ID that the DOS uses to identify a
diskette. Initialization also assures you that a diskette is properly seated in
the drive before use.

The 1541 drive has a built in autoinitialization feature. Once it encounters an
error it will retry a disk operation several times. Often it can recover from
an error on its own. If it fails, it gives up. Before doing so, though, it will
do a "bump." On a bump the read/write head is stepped outwards 45 tracks
(slight overkill) to assure that it is on track 1. The drive clatters when a
protrusion on the stepper motor's drive pulley bumps up against a mechanical
stop. (It really isn't a melt down.) The head then steps inwards to track 18
and the DOS awaits further instructions. Self initialization avoids this
scenario. Initialize every time you insert a diskette into the drive.

Initialization clears the error channel and turns off the flashing red LED.
Unless, of course, you are trying to initialize an unformatted diskette or
forgot to put one in the drive to begin with. Clearing the error channel
destroys the error status the DOS prepared for you. If error checking is
important, retrieve the error message first; then initialize the drive.


The Rename Command

Occasionally you will want to change the name of a file stored on a diskette.
To rename a file you first open the command channel and then send the rename
command like this:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "R0:NEW NAME=OLD NAME"
                CLOSE 15

ALTERNATE:      PRINT#15, "R:NEW NAME=OLD NAME"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "R0:DISPLAY T&S=DTS"
                CLOSE 15

DOS 5.1:        >R0:NEW NAME=OLD NAME
                >R:NEW NAME=OLD NAME

Again the syntax is exacting but simple to follow. The R0: means to rename on
drive 0. It is short for RENAME0:. As before, the 0 is optional on the 1541.
The next parameter is the new file name. A file name is generally alphanumeric
in nature and 16 characters are allowed at the maximum. (Commas, colons,
semicolons, and wild cards are not permitted. Cursor control and reverse video
characters should be avoided.) The new file name is followed by an " = " sign.
The last parameter is the existing or old file name. It must be spelled out
exactly as it appears in the directory. Wild cards (*,?) are not allowed. If
you make a typo on this parameter or the file does not appear in the directory,
the rename command fails. No damage is done, so relax. In the above example our
new file name is DISPLAY T&S. It replaces the old file name DTS. One final
point. You cannot rename a file that is currently open for a read or write.


The Copy Command

The copy command allows you to easily backup an existing file on your diskette.
There are three restrictions attached. First, the new file must have a
different name. Second, the copy command will not work on a relative file.
Third, you must have enough room on the diskette. The copy command looks like
this:

SYNTAX:
        OPEN 15, 8, 15
        PRINT#15, "C0:BACKUP=0:ORIGINAL"
        CLOSE 15

ALTERNATE:
        PRINT#15, "C:BACKUP=ORIGINAL"

EXAMPLE:
        OPEN 15, 8, 15
        PRINT#15, "C0:MY PROGRAM B/U=0:MY PROGRAM"
        CLOSE 15

DOS 5.l:
        >C0:BACKUP=0:ORIGINAL
        >C:BACKUP=ORIGINAL

The C is short for COPY. The new file above is called MY PROGRAM B/U. It is a
backup copy of a previous program called MY PROGRAM. Note that we must specify
the drive number twice. Again this is a holdover from a dual drive
configuration. The C does not appear twice, however. The same restrictions that
apply to the rename command are also in effect here, i.e., 16 character file
name limit, use of restricted characters, etc. The drive number is optional.
See the alternate syntax to save a few keystrokes.

It is also possible to merge two or more sequential data files using the copy
command. The syntax for this is as follows:

SYNTAX:
        OPEN 15, 8, 15
        PRINT#15, "C0:COMBINED=0:FILE1,0:FILE2,0:FILE3"
        CLOSE 15

ALTERNATE:
        PRINT#15, "C:COMBINED=FILE1,FILE2,FILE3"

EXAMPLE:
        OPEN 15, 8, 15
        PRINT#15, "C0:MAILFILE=0:NAME,O:ADDRESS,0:CITY"
        CLOSE 15

DOS 5.l:
        > CO:COMBINED=0:FILE1,0:FILE2,0:FILE3
        >C:COMBINED=FILE1,FILE2,FILE3

Our large file now consists of several files appended together. While this
feature of the copy command is available, it is rarely used. Few programming
techniques would require or ever utilize this feature. Note that this technique
cannot be used to append a subroutine onto a BASIC program; the subroutine
cannot be merged into the main program by the disk drive. You will need to use
a programmer's aid like POWER™, SYSRES™, or BASIC AID™ for the C64 to do this.


The Scratch Command

To get rid of an unwanted file, we scratch it. The only exception is an
unclosed file. An unclosed file is one that appears in the directory as having
zero blocks and whose file type is preceded by an asterisk (*SEQ, *PRG, etc.).
This will be explained below. To scratch a file, first remove the write protect
tab and key in:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "S0:FILE NAME"
                CLOSE 15

ALTERNATE:      PRINT#15, "S:FILE NAME"

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:TESTING 123"
                CLOSE 15

DOS 5.1:        >SO:FILE NAME
                >S:FILE NAME

The scratch command requires a single parameter, the file name, preceded by S
or SCRATCH. As before, the drive number is optional.

There are some variations that incorporate wild cards. Wild cards in a file
name are asterisks (*) or question marks (?). They should be used with utmost
caution since more than one file can be scratched at a time.

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:T*"
                CLOSE 15

DOS 5.1:        >S0:T*

In the above example all files beginning with the letter T, regardless of file
type, will be scratched. In the event that no file starts with the letter T,
none will be affected. Careless use of a wild card can have catastrophic
results. For example:

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:*"
                CLOSE 15

DOS 5.1:        >S0:*

The above command will scratch every file on the diskette. It is the equivalent
of performing a short new on a diskette. Be careful!

The second wild card is the question mark. It is used to mask out characters
that are not of importance. Suppose we want to scratch a number of files whose
names are all eight characters long and end in .C64. We could not use .C64* to
scratch them since the match falls at the end of the file name. However, we
could use:

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:????.C64"
                CLOSE 15

DOS 5.1:        >S0:????.C64

Note that we used four question marks in the above example. An exact match of
.C64 must occur on characters 5 through 8 of the file name. No match — no
scratch. If we had 1541.C64 and C100.C64 on the disk, both would be scratched
by the previous command. However, BACKUP.C64 would not be affected.

More than one wild card can be used within the same command. For example:

EXAMPLE:        OPEN 15, 8, 15
                PRINT#15, "S0:T?ST*"
                CLOSE 15

DOS 5.1:        >S0:T?ST*

This command would scratch files with these names: TEST, TASTY, TESTING123. The
file TOAST would not be affected. Note that it makes no sense to send a command
like this: "S0:T*ST???". The asterisk has priority over the question mark. All
characters that appear after the asterisk are ignored.

A file type that begins with a * is unclosed: *SEQ, *PRG, etc. It was never
closed properly. This can happen for a variety of reasons:

1. The diskette may have been at its physical capacity and a disk-full
   situation occurred during a save or write to a diskette.

2. A bad sector may have been encountered during a write to a diskette.

3. The file may have been left open following a write operation because you
   forgot to CLOSE the file, or you aborted the program by hitting either the
   RUN/STOP key or the RUN/STOP and the RESTORE keys.

4. Your program had a syntax error in it and the BASIC interpreter returned you
   to immediate mode.

(See Chapter 8 about how to recover an unclosed file.)

Whatever the cause, an unclosed file should never be scratched! Since the write
operation was aborted, the internal organization of the diskette (i.e., the
BAM), has been left in disarray. It does not match the actual file contents of
the diskette. Any further attempt to write to that diskette will probably cause
a loss of one or more files. Files can actually overlap one another now and you
will be left with a poisoned diskette. The DOS does have a command to decorrupt
itself. This is the validate command. When in doubt, validate your diskette!

The scratch command does not actually erase the file on your diskette. Rather
it traces the file across the surface of the diskette and frees any sectors the
file occupied. The file-type byte is also changed to a zero in the directory
which indicates to the DOS that it is no longer active. If you inadvertently
scratch a file that you didn't mean to, stop right then and there! You can
recover it. Do not attempt to write to the diskette. The sectors just freed
will be used on subsequent writes to the diskette. Once you write to the
diskette, recovery is impossible. Chapter 8 on Getting Out of Trouble shows you
how to recover a scratched file.


The Validate Command

This command tells the DOS to reconstruct its map which shows where information
is stored on the diskette, so it conforms to the files listed in the directory.
This is a simple way to decorrupt a damaged diskette. However, it is not a
failsafe command as will be explained shortly. A validate command looks like
this:

SYNTAX:         OPEN 15, 8, 15
                PRINT#15, "V0"
                CLOSE 15

ALTERNATE:      PRINT#15, "V"

DOS 5.1:        >V0
                >V

The V is an abbreviation for VALIDATE. As before, the 0 is optional for the
1541 drive.

What does a validate do? The DOS keeps a map that indicates which sectors on a
diskette are currently in use. This map is stored on track 18, sector 0. It is
referred to as the Block Availability Map or just the BAM for short. When the
validate command is issued, all blocks are freed in the BAM on the diskette
simulating a newly formatted blank diskette. The drive then picks up the first
file in the directory and chains through the entire file. As sectors are picked
up along the way, they are allocated in the BAM as currently in use. If the
file is traced successfully, all blocks associated with it are put back into
the BAM as in use. The next file is then picked up out of the directory and the
process continues. When all files have been traced, the new BAM is written to
the diskette and the internal count now matches the directory contents.

So far so good. Now let's see what happens to an unclosed file. When the DOS
encounters an unclosed file in the directory during a validate command, all it
does is change the file type byte in the directory entry to a 0 (scratched
file). No attempt is made to trace the file. When the validate operation is
complete, the unclosed file will no longer appear in a directory listing and
any blocks associated with it will be free. This is what you want to happen.
Now let's see what happens if you attempt to SCRATCH an unclosed file.

When you scratch a file, two things happen: the file-type byte in the directory
for this file is set to 0 (scratched file) and the DOS traces through the chain
of sectors that make up the file and marks each sector it encounters as
available for use (free) in the BAM. This is just what you want to have happen
for a normal file, but it can poison the diskette when you try it on an
unclosed file. Here's why. The last sector of an unclosed file was never
written out to the diskette. As a result, the second to the last sector points
to a sector that is not really part of the file. The DOS doesn't realize this
and continues to follow the "chain." If you are lucky, the "unwritten sector"
will be a empty sector (never used since the disk was formatted). If this
happens, the DOS will stop because pointers point to a non-existent track and
sector (75,1). If you are unlucky, the "unwritten sector" will be part of a
file that you scratched last week and the pointer will just happen to point
into the middle of that very important file you just saved yesterday. When this
happens, the DOS will merrily deallocate the remaining sectors in your file.
The next write operation to the diskette will see this nice big open space and
the new information will be saved right on top of your active file. Now the
situation has gone from bad to worse and is in fact pathological — hence a
poisoned disk. The only solution is to inspect each file first to ensure that
it is not tainted and then copy it onto another diskette.

The validate routine is aborted if an error (an unreadable sector) is
encountered. When it aborts, nothing radical occurs. The new BAM is not written
to the disk until the validation process has been completed. Don't worry about
the blank BAM getting you in trouble; the DOS will read the old one back in
before it allows you to write to the disk. However, the diskette still remains
corrupted with no quick remedy in sight. Chapter 8 on recovery deals with this
and other disasters.

﻿
﻿
CHAPTER 3

DISKETTE FORMATTING

When you take a new floppy diskette out of the package, it is blank. Before the
drive can store data onto it, it must be formatted. This is done by inserting
the diskette into the drive and sending a NEW command to the DOS (see Section
2.5). During "formatting" or "newing", 35 concentric tracks are written to the
diskette. Each track is made up of varying numbers of sectors/blocks where
programs and data will eventually be stored. In addition to laying down empty
blocks/sectors, the DOS creates a directory and a block availability map (BAM)
and records them on track 18.

This chapter describes the formatting process and the tracks and sectors of a
diskette. Chapter 4 describes the directory and the block availability map
(BAM).

3.1 Layout of Tracks and Sectors

During the formatting (newing) process, the DOS divides the diskette into
tracks and sectors. A track is a circular path on the diskette along which
information is stored.

Each track is concentric with the hole in the center of the diskette. There are
a total of 35 tracks numbered from 1 to 35. Track 1 is the outermost track and
track 35 is the innermost track. The read/write head may be positioned to any
given track. The position of track 1 is determined by a mechanical stop that
limits the outward movement of the read/write head. The other tracks are
identified by their distance from track 1. The diagram below indicates the
layout of the tracks on a formatted diskette.

[tracks layout diagram - omitted]

[sectors layout diagram - omitted]

Although there are only 35 tracks, the stepper motor can position the
read/write head to more than 70 different positions. This might seem to imply
that additional tracks could be recorded on the surface of the diskette to
increase its storage capacity. Unfortunately, the accuracy of the head
positioning mechanism and the width of the path of magnetization produced by
the read/write head makes the use of these "phantom" tracks unreliable. If you
would like to experiment with this, the programs described in Chapter 9 allow
you to experiment with stepping the head around.

Each track is divided into seventeen or more sectors (blocks). Each sector
holds 256 bytes of data. (Some manufacturers record data in 512 or 1024 byte
sectors.) Whenever data is read from or written to a diskette, it is done one
complete sector at a time.

On Commodore disk drives, the tracks are not divided into a fixed number of
sectors. The number of sectors depends on the track number. The outer tracks
(lower numbers) are longer and are divided into more sectors than the inner
(higher numbered) tracks. The table below summarizes how the diskette is
organized.

Organization of Tracks and Sectors on a 1541 Formatted Diskette

            Track      Range of Sector     Total Sectors   Total Bytes
   Zone    Numbers        Numbers            Per Track      Per Track
   ----    --------    ---------------     -------------   -----------
     1      1 to 17       0 to 20               21            5376
     2     18 to 24       0 to 18               19            4864
     3     25 to 30       0 to 17               18            4608
     4     31 to 35       0 to 16               17            4352

A total of 683 sectors are written at the time of initial formatting. Since the
disk rotates at a constant speed of 300 rpm, you may wonder how Commodore
manages to vary the number of sectors from zone to zone. This is accomplished
by varying the rate at which data is read or written (changing the clock rate).
Each of the four zones uses a different clock rate. This is accomplished by
using a high speed clock and dividing the clock by N, where the value of N is
determined by the zone. The table below summarizes the clock rates for each
zone.

   Zone    Tracks    Divisor      Clock Rate      Bits/Rotation
   ----   --------   -------   ----------------   -------------
    1      1 to 17     13      307,692 bits/sec     61,538.4
    2     18 to 24     14      285,714 bits/sec     57,142.8
    3     25 to 30     15      266,667 bits/sec     53,333.4
    4     31 to 35     16      250,000 bits/sec     50,000.0

This scheme provides a recording density that varies from about 4000 bits/inch
on the outer tracks to almost 6000 bits/inch on the inner tracks.

If all of the possible bits could be used for data alone, we would be able to
store a total of 2,027,676 bits or 253,459 bytes on a diskette. Unfortunately,
not all of these bytes can be used for data. The total storage capacity of a
diskette formatted on the 1541 is 174,848 bytes. The need for space to store a
directory to keep track of the location of the files on a diskette (see Chapter
4) further reduces us to an effective storage capacity of 169,984 bytes (256
bytes * 664 sectors).

3.2 Layout of a Sector

During the formatting (newing) process, the DOS creates and records onto the
diskette all 683 sectors/blocks that will eventually be used for storing
information. Each sector is comprised of two parts:

1. A header block that identifies the sector.
2. A data block that holds the 256 bytes of data.

The diagram below illustrates how these parts are arranged.

      SECTOR #0                             SECTOR #1
---------------------------------------------------------------------------
| |              | |              |#| | |              | |                |
| | HEADER BLOCK | |   DATA BLOCK |#| | | HEADER BLOCK | |   DATA BLOCK   | --+
| |              | |              |#| | |              | |                |   |
---------------------------------------------------------------------------   |
                                                                              |
                             +------------------------------------------------+
                             |
                             |             SECTOR #2   |\
                             |    ---------------------- \
                             |    |#| | |                 \
                             +--> |#| | | HEADER BLOCK     >
                                  |#| | |                 /
                                  ---------------------| /
                                                       |/
                 ---              ---
                 | |              |#|
                 | | = sync mark  |#| = inter-sec gap
                 | |              |#|
                 ---              ---

The sectors are recorded in numerical sequence along the circular track. Each
sector consists of an identifying header block followed by a data block. The
sectors are separated from each other by an inter-record gap. A special
character called a SYNC MARK is used to mark the beginning of each header or
data block.

A SYNC MARK is a very special character. It consists of 10 or more 1 bits in a
row (normally 40 of them). This particular pattern of bits only occurs at the
start of a header or data block. The hardware in the 1541 drive can detect this
character and signal the DOS that a new data or header block is coming.

If you are puzzled about why several $FF characters in a row in the data block
are not interpreted as a sync character, you may want to skip ahead to the
section on Commodore's GCR encoding scheme in Chapter 7.

3.3 The Header Block

The header block of a sector allows the DOS to identify which track and sector
is being read. It is composed of a sync mark, eight bytes of identifying
information, and a header gap. The diagram below shows the layout of a header
block.

------------------------------------------------------------------
| SYNC |  HEADER  | HEADER BLOCK | SECTOR | TRACK  | ID CHARACTER \
| MARK | BLOCK ID |   CHECKSUM   | NUMBER | NUMBER |   NUMBER 2   / ---+
------------------------------------------------------------------\    |
                                                                       |
  +--------------------------------------------------------------------+
  |
  |    -----------------------------------------------
  +--> \ ID CHARACTER | $0F BYTE | $0F BYTE | HEADER |
       /   NUMBER 1   |          |          |  GAP   |
       \----------------------------------------------

NOTE: The header is recorded on disk exactly as indicated above. The diagram on
page 54 of the 1541 User's Manual is incorrect.

Let's examine the bytes that make up the header block:

Sync Mark: This consists of 10 or more 1 bits as described above. It warns the
DOS that either a data block or a header block is coming.

Header Block ID: This is normally a $08 byte. It serves to indicate to the DOS
that this is a header block and not a data block.

Header Block Checksum: This is a checksum character used by the DOS to ensure
that the header block was read correctly. It is found by EORing the track
number, the sector number, and the two ID characters. If you are not sure what
an EOR is, you may want to read through Section 7.1.

Sector Number: This byte is the number of this particular sector. The sectors
are numbered consecutively around a track.

Track Number: This byte is the number of this particular track. The DOS uses
this byte to check to be sure that the record/play head is positioned to the
correct track.

ID Character #2: This is the second ID character that you specified in the NEW
command when the diskette was formatted (e.g., the 1 in "N0:GAMES,V1"). It is
sometimes referred to as the ID HI. The DOS checks this byte against a master
disk ID to ensure that you have not swapped diskettes.

ID Character #1: This is the first ID character that you specified in the NEW
command when the diskette was formatted (e.g., the V in "N0:GAMES,V1"). It is
sometimes referred to as the ID LO. The DOS checks this byte against a master
disk ID to ensure that you have not swapped diskettes.

$0F Bytes: These bytes are used as padding (spacing) by the DOS during initial
formatting. They are called "OFF" bytes. Once formatting is complete OFF bytes
are never referenced again.

Header Gap: The header gap consists of eight $55 bytes. These eight bytes are
used to provide breathing room between the header block and the data block. The
DOS never reads these bytes. They allow the DOS time to set-up for reading the
data block that follows. NOTE: The 4040 drive uses a nine byte header gap. This
is one of the reasons why 1541 drives and 4040 drives are NOT WRITE COMPATIBLE!
See Chapter 9 for more information.

NOTE: A header block is written only during the formatting process. It is never
rewritten again, period.

3.4 The Data Block

The data block of a sector stores the 256 data bytes for this sector. It is
composed of a sync mark, a data block ID character, the 256 bytes of data, a
data block checksum byte, two off bytes, and an inter-sector gap. The diagram
below depicts the layout of a data block.

-------------------------------------------------------------------
| SYNC | DATA  |      256       | DATA     | $00  | $00  | INTER- |
| MARK | BLOCK |   DATA BYTES   | BLOCK    | BYTE | BYTE | SECTOR | --+
|      | ID    |                | CHECKSUM |      |      | GAP    |   |
-------------------------------------------------------------------   |
                                                                      |
                           +------------------------------------------+
                           |
                           |                           |\
                           |    ------------------------ \
                           |    |  SYNC |  HEADER |       \
                           +--> |  MARK |  BLOCK  |        >
                                |       |  ID     |       /
                                ------------------------ /
                                                       |/

Let's examine the bytes that make up the data block:

Sync mark: This consists of 10 or more 1 bits as previously described. It warns
the DOS that either a data block or a header block is coming.

Data Block ID: This byte is normally a $07. It serves to indicate to the DOS
that this is a data block and not a header block ($08).

256 Data Bytes: This is the actual data stored in the sector. See Chapter 4
about how Commodore uses the first two bytes as a forward track and sector
pointer instead of actual data.

Data Block Checksum: This is a checksum character used by the DOS to ensure
that the data block was read correctly. It is found by EORing all 256 data
bytes together.

$00 Bytes: These two bytes are also called OFF bytes. They are used to pad a
data block before it is written. They are not referenced again by the DOS.

Inter-sector Gap: This is also known as the "tail gap." Its purpose is to
provide breathing room between the end of the data block and the start of the
next sector. The length of the gap varies from zone to zone and from one drive
to another (see the chart in Section 7.1). Between consecutive sectors the gap
is normally 4 to 12 bytes long. The gap between the last sector on a track and
sector zero is often longer — up to 100 bytes in length. The gap is designed to
be long enough so that if you write a data block on a day when your drive is
turning slightly faster than 300 rpm, you won't overwrite the start of the next
sector. (Your drive may not be turning at exactly 300 rpm all the time because
of fluctuations in the power supplied to your home or office, mechanical wear,
belt slippage, changes in temperature, etc.) Note that the DOS never reads
these bytes.

The entire data block (including the preceding sync mark) is rewritten each
time data is recorded on a diskette.

This concludes our overview on how a diskette is formatted. Additional details
about how bytes are encoded on the surface of a diskette are provided in
Section 7.1. The actual recording process is described in Section 9.7.

﻿
﻿
